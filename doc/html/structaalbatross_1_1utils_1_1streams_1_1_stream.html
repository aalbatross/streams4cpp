<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>streams4cpp: aalbatross::utils::streams::Stream&lt; T, S &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">streams4cpp<span id="projectnumber">&#160;0.0.1</span>
   </div>
   <div id="projectbrief">Functional streaming in C++.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('structaalbatross_1_1utils_1_1streams_1_1_stream.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structaalbatross_1_1utils_1_1streams_1_1_stream-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">aalbatross::utils::streams::Stream&lt; T, S &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>AType sequence of elements supporting sequential and parallel aggregate operations.  
 <a href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="stream_8h_source.html">stream.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream_1_1_view.html">View</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a view of underlying <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html" title="AType sequence of elements supporting sequential and parallel aggregate operations.">Stream</a>.  <a href="structaalbatross_1_1utils_1_1streams_1_1_stream_1_1_view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4365896733d44b155ad5f6f3948a6523"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#a4365896733d44b155ad5f6f3948a6523">Stream</a> (std::shared_ptr&lt; <a class="el" href="structaalbatross_1_1utils_1_1iterators_1_1_iterator.html">iterators::Iterator</a>&lt; S &gt; &gt; source, std::function&lt; std::unique_ptr&lt; <a class="el" href="structaalbatross_1_1utils_1_1iterators_1_1_iterator.html">iterators::Iterator</a>&lt; T &gt; &gt;(<a class="el" href="structaalbatross_1_1utils_1_1iterators_1_1_iterator.html">iterators::Iterator</a>&lt; S &gt; &amp;)&gt; mapper)</td></tr>
<tr class="separator:a4365896733d44b155ad5f6f3948a6523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab792fc5392cbe829658ebbc437146d9f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#ab792fc5392cbe829658ebbc437146d9f">Stream</a> (std::shared_ptr&lt; <a class="el" href="structaalbatross_1_1utils_1_1iterators_1_1_iterator.html">iterators::Iterator</a>&lt; S &gt; &gt; &amp;&amp;source)</td></tr>
<tr class="separator:ab792fc5392cbe829658ebbc437146d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34bce9d4eb452a155ef81089c899792d"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:a34bce9d4eb452a155ef81089c899792d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#a34bce9d4eb452a155ef81089c899792d">Stream</a> (Iter &amp;&amp;begin, Iter &amp;&amp;end)</td></tr>
<tr class="separator:a34bce9d4eb452a155ef81089c899792d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4a329c78c2a2ca874be8edba2bb79d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#a9d4a329c78c2a2ca874be8edba2bb79d">allMatch</a> (std::function&lt; bool(T)&gt; predicate)</td></tr>
<tr class="memdesc:a9d4a329c78c2a2ca874be8edba2bb79d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether all elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result. If the stream is empty then true is returned and the predicate is not evaluated.  <br /></td></tr>
<tr class="separator:a9d4a329c78c2a2ca874be8edba2bb79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11998bec9ec28f0adcd439925c2dc709"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#a11998bec9ec28f0adcd439925c2dc709">anyMatch</a> (std::function&lt; bool(T)&gt; predicate)</td></tr>
<tr class="memdesc:a11998bec9ec28f0adcd439925c2dc709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether any elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result. If the stream is empty then false is returned and the predicate is not evaluated.  <br /></td></tr>
<tr class="separator:a11998bec9ec28f0adcd439925c2dc709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef893b9028bc61a50e09e5748f497ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#aeef893b9028bc61a50e09e5748f497ea">noneMatch</a> (std::function&lt; bool(T)&gt; predicate)</td></tr>
<tr class="memdesc:aeef893b9028bc61a50e09e5748f497ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether no elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result. If the stream is empty then true is returned and the predicate is not evaluated.  <br /></td></tr>
<tr class="separator:aeef893b9028bc61a50e09e5748f497ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77b75ab264a3f184863be878c3683f5"><td class="memItemLeft" align="right" valign="top">std::optional&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#ae77b75ab264a3f184863be878c3683f5">head</a> ()</td></tr>
<tr class="memdesc:ae77b75ab264a3f184863be878c3683f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Optional describing the first element of this stream, or an empty Optional if the stream is empty. If the stream has no encounter order, then any element may be returned.  <br /></td></tr>
<tr class="separator:ae77b75ab264a3f184863be878c3683f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ea3f0ad0606ae9a5ee61a0a0caba2b"><td class="memItemLeft" align="right" valign="top">std::optional&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#a37ea3f0ad0606ae9a5ee61a0a0caba2b">tail</a> ()</td></tr>
<tr class="memdesc:a37ea3f0ad0606ae9a5ee61a0a0caba2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Optional describing the last element of this stream, or an empty Optional if the stream is empty. If the stream has no encounter order, then any element may be returned.  <br /></td></tr>
<tr class="separator:a37ea3f0ad0606ae9a5ee61a0a0caba2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293ff4f66804bcc0c997fb34949006b7"><td class="memItemLeft" align="right" valign="top">std::optional&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#a293ff4f66804bcc0c997fb34949006b7">find</a> (std::function&lt; bool(T)&gt; predicate)</td></tr>
<tr class="memdesc:a293ff4f66804bcc0c997fb34949006b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first element of the sequence satisfying a predicate, if any.  <br /></td></tr>
<tr class="separator:a293ff4f66804bcc0c997fb34949006b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98496ad590f162ec9732ea8f137d057e"><td class="memTemplParams" colspan="2">template&lt;typename Discriminator &gt; </td></tr>
<tr class="memitem:a98496ad590f162ec9732ea8f137d057e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#a98496ad590f162ec9732ea8f137d057e">groupedBy</a> (Discriminator &amp;&amp;discriminator)</td></tr>
<tr class="separator:a98496ad590f162ec9732ea8f137d057e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5698b36ee84d43a5d927a79f9668709"><td class="memTemplParams" colspan="2">template&lt;typename Fun &gt; </td></tr>
<tr class="memitem:af5698b36ee84d43a5d927a79f9668709"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#af5698b36ee84d43a5d927a79f9668709">map</a> (Fun &amp;&amp;mapper)</td></tr>
<tr class="memdesc:af5698b36ee84d43a5d927a79f9668709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a stream consisting of the results of applying the given function to the elements of this stream.  <br /></td></tr>
<tr class="separator:af5698b36ee84d43a5d927a79f9668709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081854ef30587c30030649f5d7ff517b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">Stream</a>&lt; T, S &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#a081854ef30587c30030649f5d7ff517b">filter</a> (std::function&lt; bool(T)&gt; predicate)</td></tr>
<tr class="memdesc:a081854ef30587c30030649f5d7ff517b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects all elements of this stream which satisfy a predicate.  <br /></td></tr>
<tr class="separator:a081854ef30587c30030649f5d7ff517b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075d4e6708a74c3562cdebe2aa47ffc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">Stream</a>&lt; T, S &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#a075d4e6708a74c3562cdebe2aa47ffc3">limit</a> (const size_t <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#a93cfed41d531e1898a783c45919fabf6">count</a>)</td></tr>
<tr class="memdesc:a075d4e6708a74c3562cdebe2aa47ffc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a stream consisting of the elements of this stream, truncated to be no longer than count in length.  <br /></td></tr>
<tr class="separator:a075d4e6708a74c3562cdebe2aa47ffc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a560be38689dad83d019977ecb0c0fd4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">Stream</a>&lt; T, S &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#a560be38689dad83d019977ecb0c0fd4a">skip</a> (const size_t <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#a93cfed41d531e1898a783c45919fabf6">count</a>)</td></tr>
<tr class="memdesc:a560be38689dad83d019977ecb0c0fd4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a stream consisting of the remaining elements of this stream after discarding the first count elements of the stream.  <br /></td></tr>
<tr class="separator:a560be38689dad83d019977ecb0c0fd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914d1b4638843814ae0ea3e846c03613"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">Stream</a>&lt; T, S &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#a914d1b4638843814ae0ea3e846c03613">sorted</a> (std::function&lt; int(T, T)&gt; comparator)</td></tr>
<tr class="memdesc:a914d1b4638843814ae0ea3e846c03613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a stream consisting of the elements of this stream, sorted according to comparator.  <br /></td></tr>
<tr class="separator:a914d1b4638843814ae0ea3e846c03613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9a3cc5f5004253135ec25f7838e30c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">Stream</a>&lt; T, S &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#aaf9a3cc5f5004253135ec25f7838e30c">distinct</a> ()</td></tr>
<tr class="memdesc:aaf9a3cc5f5004253135ec25f7838e30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a stream consisting of the distinct elements (according to element1 == element2) of this stream.  <br /></td></tr>
<tr class="separator:aaf9a3cc5f5004253135ec25f7838e30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f3163bac8029ba1221b87081496f4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">Stream</a>&lt; T, S &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#a25f3163bac8029ba1221b87081496f4a">reverse</a> ()</td></tr>
<tr class="memdesc:a25f3163bac8029ba1221b87081496f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">AType list consisting of all elements of this list in reverse order.  <br /></td></tr>
<tr class="separator:a25f3163bac8029ba1221b87081496f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed1e8eed678c16e9ee842a76c8903b5"><td class="memItemLeft" align="right" valign="top">std::optional&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#a4ed1e8eed678c16e9ee842a76c8903b5">max</a> ()</td></tr>
<tr class="memdesc:a4ed1e8eed678c16e9ee842a76c8903b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max of all the elements in this stream.  <br /></td></tr>
<tr class="separator:a4ed1e8eed678c16e9ee842a76c8903b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e15086cc68db5fe31cc09e3c681f8d"><td class="memItemLeft" align="right" valign="top">std::optional&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#ae4e15086cc68db5fe31cc09e3c681f8d">min</a> ()</td></tr>
<tr class="memdesc:ae4e15086cc68db5fe31cc09e3c681f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Min of all the elements in this stream.  <br /></td></tr>
<tr class="separator:ae4e15086cc68db5fe31cc09e3c681f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3056ce762ea6e06c418f646ec9e71ec3"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#a3056ce762ea6e06c418f646ec9e71ec3">sum</a> ()</td></tr>
<tr class="memdesc:a3056ce762ea6e06c418f646ec9e71ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of all the elements in this stream.  <br /></td></tr>
<tr class="separator:a3056ce762ea6e06c418f646ec9e71ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6f59a8873c9cc53b23d3de14b4781e"><td class="memTemplParams" colspan="2">template&lt;typename Supplier , typename Accumulator , typename Finisher &gt; </td></tr>
<tr class="memitem:a4d6f59a8873c9cc53b23d3de14b4781e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#a4d6f59a8873c9cc53b23d3de14b4781e">collect</a> (<a class="el" href="classaalbatross_1_1utils_1_1streams_1_1_collector.html">Collector</a>&lt; Supplier, Accumulator, Finisher &gt; &amp;&amp;collector)</td></tr>
<tr class="separator:a4d6f59a8873c9cc53b23d3de14b4781e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38251991ba6fa1f4c731c4123c917e27"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#a38251991ba6fa1f4c731c4123c917e27">reduce</a> (T identity, std::function&lt; T(T, T)&gt; binaryAccumulator)</td></tr>
<tr class="memdesc:a38251991ba6fa1f4c731c4123c917e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction on the elements of this stream, using the provided identity value and an associative accumulation function, and returns the reduced value.  <br /></td></tr>
<tr class="separator:a38251991ba6fa1f4c731c4123c917e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93cfed41d531e1898a783c45919fabf6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#a93cfed41d531e1898a783c45919fabf6">count</a> ()</td></tr>
<tr class="memdesc:a93cfed41d531e1898a783c45919fabf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the count of elements in this stream. This is a special case of a reduction and is equivalent to:  <br /></td></tr>
<tr class="separator:a93cfed41d531e1898a783c45919fabf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422801da412060181b664ffb11dbc18b"><td class="memTemplParams" colspan="2">template&lt;typename Consumer &gt; </td></tr>
<tr class="memitem:a422801da412060181b664ffb11dbc18b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#a422801da412060181b664ffb11dbc18b">forEach</a> (Consumer &amp;&amp;consumer)</td></tr>
<tr class="separator:a422801da412060181b664ffb11dbc18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771e5bc13d917cb438258053dfe07088"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#a771e5bc13d917cb438258053dfe07088">toSet</a> ()</td></tr>
<tr class="memdesc:a771e5bc13d917cb438258053dfe07088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns set of input elements.  <br /></td></tr>
<tr class="separator:a771e5bc13d917cb438258053dfe07088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b21a4cd7c868ae42b941af8f576f323"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#a0b21a4cd7c868ae42b941af8f576f323">toUnorderedSet</a> ()</td></tr>
<tr class="memdesc:a0b21a4cd7c868ae42b941af8f576f323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns unordered set of input elements.  <br /></td></tr>
<tr class="separator:a0b21a4cd7c868ae42b941af8f576f323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a12108b8c6dfc76c411da94a2a01479"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#a7a12108b8c6dfc76c411da94a2a01479">toVector</a> ()</td></tr>
<tr class="memdesc:a7a12108b8c6dfc76c411da94a2a01479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vector of input elements.  <br /></td></tr>
<tr class="separator:a7a12108b8c6dfc76c411da94a2a01479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad644574f4c70aec870341838989565ee"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#ad644574f4c70aec870341838989565ee">toList</a> ()</td></tr>
<tr class="memdesc:ad644574f4c70aec870341838989565ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns list of input elements.  <br /></td></tr>
<tr class="separator:ad644574f4c70aec870341838989565ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4567e0515bde107a0c817351a94939"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#a5b4567e0515bde107a0c817351a94939">toDeque</a> ()</td></tr>
<tr class="memdesc:a5b4567e0515bde107a0c817351a94939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns deque of input elements.  <br /></td></tr>
<tr class="separator:a5b4567e0515bde107a0c817351a94939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618f2ae42a37d92f0e58b171c6e4e19e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream_1_1_view.html">View</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#a618f2ae42a37d92f0e58b171c6e4e19e">view</a> ()</td></tr>
<tr class="memdesc:a618f2ae42a37d92f0e58b171c6e4e19e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html" title="AType sequence of elements supporting sequential and parallel aggregate operations.">Stream</a> <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream_1_1_view.html" title="Creates a view of underlying Stream.">View</a> which copies internal iterator.  <br /></td></tr>
<tr class="separator:a618f2ae42a37d92f0e58b171c6e4e19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, typename S = T&gt;<br />
class aalbatross::utils::streams::Stream&lt; T, S &gt;</div><p>AType sequence of elements supporting sequential and parallel aggregate operations. </p>
<p>To perform a computation, stream operations are composed into a stream pipeline. AType stream pipeline consists of a source (which might be an array, a collection, a generator function, an I/O channel, etc), zero or more intermediate operations (which transform a stream into another stream, such as filter(Predicate)), and a terminal operation (which produces a result or side-effect, such as <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#a93cfed41d531e1898a783c45919fabf6" title="Returns the count of elements in this stream. This is a special case of a reduction and is equivalent...">count()</a> or forEach(Consumer)). Streams are lazy; computation on the source data is only performed when the terminal operation is initiated, and source elements are consumed only as needed. Collections and streams, while bearing some superficial similarities, have different goals. Collections are primarily concerned with the efficient management of, and access to, their elements. By contrast, streams do not provide a means to directly access or manipulate their elements, and are instead concerned with declaratively describing their source and the computational operations which will be performed in aggregate on that source. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>target stream type </td></tr>
    <tr><td class="paramname">S</td><td>source stream type </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4365896733d44b155ad5f6f3948a6523" name="a4365896733d44b155ad5f6f3948a6523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4365896733d44b155ad5f6f3948a6523">&#9670;&#160;</a></span>Stream() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">aalbatross::utils::streams::Stream</a>&lt; T, S &gt;::Stream </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structaalbatross_1_1utils_1_1iterators_1_1_iterator.html">iterators::Iterator</a>&lt; S &gt; &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; std::unique_ptr&lt; <a class="el" href="structaalbatross_1_1utils_1_1iterators_1_1_iterator.html">iterators::Iterator</a>&lt; T &gt; &gt;(<a class="el" href="structaalbatross_1_1utils_1_1iterators_1_1_iterator.html">iterators::Iterator</a>&lt; S &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>mapper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab792fc5392cbe829658ebbc437146d9f" name="ab792fc5392cbe829658ebbc437146d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab792fc5392cbe829658ebbc437146d9f">&#9670;&#160;</a></span>Stream() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">aalbatross::utils::streams::Stream</a>&lt; T, S &gt;::Stream </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structaalbatross_1_1utils_1_1iterators_1_1_iterator.html">iterators::Iterator</a>&lt; S &gt; &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a34bce9d4eb452a155ef81089c899792d" name="a34bce9d4eb452a155ef81089c899792d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34bce9d4eb452a155ef81089c899792d">&#9670;&#160;</a></span>Stream() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T&gt; </div>
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">aalbatross::utils::streams::Stream</a>&lt; T, S &gt;::Stream </td>
          <td>(</td>
          <td class="paramtype">Iter &amp;&amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter &amp;&amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9d4a329c78c2a2ca874be8edba2bb79d" name="a9d4a329c78c2a2ca874be8edba2bb79d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d4a329c78c2a2ca874be8edba2bb79d">&#9670;&#160;</a></span>allMatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">aalbatross::utils::streams::Stream</a>&lt; T, S &gt;::allMatch </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(T)&gt;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether all elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result. If the stream is empty then true is returned and the predicate is not evaluated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>stateless predicate to apply to elements of this stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if either all elements of the stream match the provided predicate or the stream is empty, otherwise false </dd></dl>

</div>
</div>
<a id="a11998bec9ec28f0adcd439925c2dc709" name="a11998bec9ec28f0adcd439925c2dc709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11998bec9ec28f0adcd439925c2dc709">&#9670;&#160;</a></span>anyMatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">aalbatross::utils::streams::Stream</a>&lt; T, S &gt;::anyMatch </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(T)&gt;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether any elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result. If the stream is empty then false is returned and the predicate is not evaluated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>stateless predicate to apply to elements of this stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any elements of the stream match the provided predicate, otherwise false </dd></dl>

</div>
</div>
<a id="a4d6f59a8873c9cc53b23d3de14b4781e" name="a4d6f59a8873c9cc53b23d3de14b4781e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d6f59a8873c9cc53b23d3de14b4781e">&#9670;&#160;</a></span>collect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T&gt; </div>
<div class="memtemplate">
template&lt;typename Supplier , typename Accumulator , typename Finisher &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">aalbatross::utils::streams::Stream</a>&lt; T, S &gt;::collect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaalbatross_1_1utils_1_1streams_1_1_collector.html">Collector</a>&lt; Supplier, Accumulator, Finisher &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>collector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93cfed41d531e1898a783c45919fabf6" name="a93cfed41d531e1898a783c45919fabf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93cfed41d531e1898a783c45919fabf6">&#9670;&#160;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">aalbatross::utils::streams::Stream</a>&lt; T, S &gt;::count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the count of elements in this stream. This is a special case of a reduction and is equivalent to: </p>
<dl class="section return"><dt>Returns</dt><dd>size of the stream. </dd></dl>

</div>
</div>
<a id="aaf9a3cc5f5004253135ec25f7838e30c" name="aaf9a3cc5f5004253135ec25f7838e30c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf9a3cc5f5004253135ec25f7838e30c">&#9670;&#160;</a></span>distinct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">Stream</a>&lt; T, S &gt; <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">aalbatross::utils::streams::Stream</a>&lt; T, S &gt;::distinct </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a stream consisting of the distinct elements (according to element1 == element2) of this stream. </p>
<dl class="section return"><dt>Returns</dt><dd>new stream with unique elements. </dd></dl>

</div>
</div>
<a id="a081854ef30587c30030649f5d7ff517b" name="a081854ef30587c30030649f5d7ff517b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a081854ef30587c30030649f5d7ff517b">&#9670;&#160;</a></span>filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">Stream</a>&lt; T, S &gt; <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">aalbatross::utils::streams::Stream</a>&lt; T, S &gt;::filter </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(T)&gt;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Selects all elements of this stream which satisfy a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>stateless predicated which is applied to all elements of stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html" title="AType sequence of elements supporting sequential and parallel aggregate operations.">Stream</a> of filtered elements as per predicate. </dd></dl>

</div>
</div>
<a id="a293ff4f66804bcc0c997fb34949006b7" name="a293ff4f66804bcc0c997fb34949006b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a293ff4f66804bcc0c997fb34949006b7">&#9670;&#160;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; T &gt; <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">aalbatross::utils::streams::Stream</a>&lt; T, S &gt;::find </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(T)&gt;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first element of the sequence satisfying a predicate, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>stateless predicate to apply to elements of this stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an Optional describing the first element of this stream which matches with this predicate, or an empty Optional if the stream is empty </dd></dl>

</div>
</div>
<a id="a422801da412060181b664ffb11dbc18b" name="a422801da412060181b664ffb11dbc18b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422801da412060181b664ffb11dbc18b">&#9670;&#160;</a></span>forEach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T&gt; </div>
<div class="memtemplate">
template&lt;typename Consumer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">aalbatross::utils::streams::Stream</a>&lt; T, S &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">Consumer &amp;&amp;&#160;</td>
          <td class="paramname"><em>consumer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs an action for each element of this stream. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Consumer</td><td>type of Consumer function a non-interfering action to perform on the elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">consumer</td><td>a non-interfering Consumer action to perform on the elements </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98496ad590f162ec9732ea8f137d057e" name="a98496ad590f162ec9732ea8f137d057e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98496ad590f162ec9732ea8f137d057e">&#9670;&#160;</a></span>groupedBy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T&gt; </div>
<div class="memtemplate">
template&lt;typename Discriminator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">aalbatross::utils::streams::Stream</a>&lt; T, S &gt;::groupedBy </td>
          <td>(</td>
          <td class="paramtype">Discriminator &amp;&amp;&#160;</td>
          <td class="paramname"><em>discriminator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae77b75ab264a3f184863be878c3683f5" name="ae77b75ab264a3f184863be878c3683f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae77b75ab264a3f184863be878c3683f5">&#9670;&#160;</a></span>head()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; T &gt; <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">aalbatross::utils::streams::Stream</a>&lt; T, S &gt;::head </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an Optional describing the first element of this stream, or an empty Optional if the stream is empty. If the stream has no encounter order, then any element may be returned. </p>
<dl class="section return"><dt>Returns</dt><dd>an Optional describing the first element of this stream, or an empty Optional if the stream is empty </dd></dl>

</div>
</div>
<a id="a075d4e6708a74c3562cdebe2aa47ffc3" name="a075d4e6708a74c3562cdebe2aa47ffc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075d4e6708a74c3562cdebe2aa47ffc3">&#9670;&#160;</a></span>limit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">Stream</a>&lt; T, S &gt; <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">aalbatross::utils::streams::Stream</a>&lt; T, S &gt;::limit </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a stream consisting of the elements of this stream, truncated to be no longer than count in length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>max size of the stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html" title="AType sequence of elements supporting sequential and parallel aggregate operations.">Stream</a> object returning elements of the provided size. </dd></dl>

</div>
</div>
<a id="af5698b36ee84d43a5d927a79f9668709" name="af5698b36ee84d43a5d927a79f9668709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5698b36ee84d43a5d927a79f9668709">&#9670;&#160;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T&gt; </div>
<div class="memtemplate">
template&lt;typename Fun &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">Stream</a>&lt; E, S &gt; <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">aalbatross::utils::streams::Stream</a>&lt; T, S &gt;::map </td>
          <td>(</td>
          <td class="paramtype">Fun &amp;&amp;&#160;</td>
          <td class="paramname"><em>mapper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a stream consisting of the results of applying the given function to the elements of this stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Fun</td><td>It is a type of function which can map elements from one type to another. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapper</td><td>is mapping function an object of Fun to transform element of stream from one type to other </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html" title="AType sequence of elements supporting sequential and parallel aggregate operations.">Stream</a> object with composed mapper function. </dd></dl>

</div>
</div>
<a id="a4ed1e8eed678c16e9ee842a76c8903b5" name="a4ed1e8eed678c16e9ee842a76c8903b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed1e8eed678c16e9ee842a76c8903b5">&#9670;&#160;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; T &gt; <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">aalbatross::utils::streams::Stream</a>&lt; T, S &gt;::max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Max of all the elements in this stream. </p>
<dl class="section return"><dt>Returns</dt><dd>Optionally max element if the stream is non empty else empty optional. </dd></dl>

</div>
</div>
<a id="ae4e15086cc68db5fe31cc09e3c681f8d" name="ae4e15086cc68db5fe31cc09e3c681f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e15086cc68db5fe31cc09e3c681f8d">&#9670;&#160;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; T &gt; <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">aalbatross::utils::streams::Stream</a>&lt; T, S &gt;::min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Min of all the elements in this stream. </p>
<dl class="section return"><dt>Returns</dt><dd>Optionally min element if the stream is non empty else empty optional. </dd></dl>

</div>
</div>
<a id="aeef893b9028bc61a50e09e5748f497ea" name="aeef893b9028bc61a50e09e5748f497ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef893b9028bc61a50e09e5748f497ea">&#9670;&#160;</a></span>noneMatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">aalbatross::utils::streams::Stream</a>&lt; T, S &gt;::noneMatch </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(T)&gt;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether no elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result. If the stream is empty then true is returned and the predicate is not evaluated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>stateless predicate to apply to elements of this stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if either no elements of the stream match the provided predicate or the stream is empty, otherwise false </dd></dl>

</div>
</div>
<a id="a38251991ba6fa1f4c731c4123c917e27" name="a38251991ba6fa1f4c731c4123c917e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38251991ba6fa1f4c731c4123c917e27">&#9670;&#160;</a></span>reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">aalbatross::utils::streams::Stream</a>&lt; T, S &gt;::reduce </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; T(T, T)&gt;&#160;</td>
          <td class="paramname"><em>binaryAccumulator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction on the elements of this stream, using the provided identity value and an associative accumulation function, and returns the reduced value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">identity</td><td>the identity value for the accumulating function </td></tr>
    <tr><td class="paramname">binaryAccumulator</td><td>an associative, non-interfering, stateless function for combining two values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the reduction </dd></dl>

</div>
</div>
<a id="a25f3163bac8029ba1221b87081496f4a" name="a25f3163bac8029ba1221b87081496f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25f3163bac8029ba1221b87081496f4a">&#9670;&#160;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">Stream</a>&lt; T, S &gt; <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">aalbatross::utils::streams::Stream</a>&lt; T, S &gt;::reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>AType list consisting of all elements of this list in reverse order. </p>
<dl class="section return"><dt>Returns</dt><dd>a new stream representing original stream elements in reverse order. </dd></dl>

</div>
</div>
<a id="a560be38689dad83d019977ecb0c0fd4a" name="a560be38689dad83d019977ecb0c0fd4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a560be38689dad83d019977ecb0c0fd4a">&#9670;&#160;</a></span>skip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">Stream</a>&lt; T, S &gt; <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">aalbatross::utils::streams::Stream</a>&lt; T, S &gt;::skip </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a stream consisting of the remaining elements of this stream after discarding the first count elements of the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>the number of leading elements to skip </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new stream with skipped elements from stream. </dd></dl>

</div>
</div>
<a id="a914d1b4638843814ae0ea3e846c03613" name="a914d1b4638843814ae0ea3e846c03613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a914d1b4638843814ae0ea3e846c03613">&#9670;&#160;</a></span>sorted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">Stream</a>&lt; T, S &gt; <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">aalbatross::utils::streams::Stream</a>&lt; T, S &gt;::sorted </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; int(T, T)&gt;&#160;</td>
          <td class="paramname"><em>comparator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a stream consisting of the elements of this stream, sorted according to comparator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comparator</td><td>stateless Comparator to be used to compare stream elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new stream </dd></dl>

</div>
</div>
<a id="a3056ce762ea6e06c418f646ec9e71ec3" name="a3056ce762ea6e06c418f646ec9e71ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3056ce762ea6e06c418f646ec9e71ec3">&#9670;&#160;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">aalbatross::utils::streams::Stream</a>&lt; T, S &gt;::sum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sum of all the elements in this stream. </p>
<dl class="section return"><dt>Returns</dt><dd>sum </dd></dl>

</div>
</div>
<a id="a37ea3f0ad0606ae9a5ee61a0a0caba2b" name="a37ea3f0ad0606ae9a5ee61a0a0caba2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ea3f0ad0606ae9a5ee61a0a0caba2b">&#9670;&#160;</a></span>tail()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; T &gt; <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">aalbatross::utils::streams::Stream</a>&lt; T, S &gt;::tail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an Optional describing the last element of this stream, or an empty Optional if the stream is empty. If the stream has no encounter order, then any element may be returned. </p>
<dl class="section return"><dt>Returns</dt><dd>an Optional describing the last element of this stream, or an empty Optional if the stream is empty </dd></dl>

</div>
</div>
<a id="a5b4567e0515bde107a0c817351a94939" name="a5b4567e0515bde107a0c817351a94939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b4567e0515bde107a0c817351a94939">&#9670;&#160;</a></span>toDeque()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">aalbatross::utils::streams::Stream</a>&lt; T, S &gt;::toDeque </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns deque of input elements. </p>
<p>std::deque&lt;T&gt; <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#a5b4567e0515bde107a0c817351a94939" title="Returns deque of input elements.">toDeque()</a> </p><dl class="section return"><dt>Returns</dt><dd>stream as std::deque </dd></dl>

</div>
</div>
<a id="ad644574f4c70aec870341838989565ee" name="ad644574f4c70aec870341838989565ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad644574f4c70aec870341838989565ee">&#9670;&#160;</a></span>toList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">aalbatross::utils::streams::Stream</a>&lt; T, S &gt;::toList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns list of input elements. </p>
<p>std::list&lt;T&gt; <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#ad644574f4c70aec870341838989565ee" title="Returns list of input elements.">toList()</a> </p><dl class="section return"><dt>Returns</dt><dd>stream as std::list </dd></dl>

</div>
</div>
<a id="a771e5bc13d917cb438258053dfe07088" name="a771e5bc13d917cb438258053dfe07088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a771e5bc13d917cb438258053dfe07088">&#9670;&#160;</a></span>toSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; T &gt; <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">aalbatross::utils::streams::Stream</a>&lt; T, S &gt;::toSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns set of input elements. </p>
<dl class="section return"><dt>Returns</dt><dd>stream as set </dd></dl>

</div>
</div>
<a id="a0b21a4cd7c868ae42b941af8f576f323" name="a0b21a4cd7c868ae42b941af8f576f323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b21a4cd7c868ae42b941af8f576f323">&#9670;&#160;</a></span>toUnorderedSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; T &gt; <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">aalbatross::utils::streams::Stream</a>&lt; T, S &gt;::toUnorderedSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns unordered set of input elements. </p>
<dl class="section return"><dt>Returns</dt><dd>stream as unordered set </dd></dl>

</div>
</div>
<a id="a7a12108b8c6dfc76c411da94a2a01479" name="a7a12108b8c6dfc76c411da94a2a01479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a12108b8c6dfc76c411da94a2a01479">&#9670;&#160;</a></span>toVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">aalbatross::utils::streams::Stream</a>&lt; T, S &gt;::toVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns vector of input elements. </p>
<p>std::vector&lt;T&gt; <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html#a7a12108b8c6dfc76c411da94a2a01479" title="Returns vector of input elements.">toVector()</a> </p><dl class="section return"><dt>Returns</dt><dd>stream as std::vector </dd></dl>

</div>
</div>
<a id="a618f2ae42a37d92f0e58b171c6e4e19e" name="a618f2ae42a37d92f0e58b171c6e4e19e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618f2ae42a37d92f0e58b171c6e4e19e">&#9670;&#160;</a></span>view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StreamView&lt; T, S &gt; <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">aalbatross::utils::streams::Stream</a>&lt; T, S &gt;::view </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html" title="AType sequence of elements supporting sequential and parallel aggregate operations.">Stream</a> <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream_1_1_view.html" title="Creates a view of underlying Stream.">View</a> which copies internal iterator. </p>
<dl class="section return"><dt>Returns</dt><dd>Stream&lt;S&gt;::View of the <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html" title="AType sequence of elements supporting sequential and parallel aggregate operations.">Stream</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>aalbatross/utils/streams/<a class="el" href="stream_8h_source.html">stream.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceaalbatross.html">aalbatross</a></li><li class="navelem"><a class="el" href="namespaceaalbatross_1_1utils.html">utils</a></li><li class="navelem"><a class="el" href="namespaceaalbatross_1_1utils_1_1streams.html">streams</a></li><li class="navelem"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html">Stream</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
