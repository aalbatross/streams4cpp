<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>streams4cpp: aalbatross::utils::streams::UBStream&lt; T, S, BASE &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">streams4cpp<span id="projectnumber">&#160;0.0.2</span>
   </div>
   <div id="projectbrief">Functional streaming in C++.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">aalbatross::utils::streams::UBStream&lt; T, S, BASE &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A sequence of elements supporting sequential and parallel aggregate operations on unbounded stream.  
 <a href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ub__stream_8h_source.html">ub_stream.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a755f7aa1e1f9631beb277a5f4d4cd077"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:a755f7aa1e1f9631beb277a5f4d4cd077"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html#a755f7aa1e1f9631beb277a5f4d4cd077">UBStream</a> (Iter &amp;&amp;begin, Iter &amp;&amp;end)</td></tr>
<tr class="separator:a755f7aa1e1f9631beb277a5f4d4cd077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3720091da41e0914322219d223bafbf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html#ac3720091da41e0914322219d223bafbf">UBStream</a> (std::shared_ptr&lt; <a class="el" href="structaalbatross_1_1utils_1_1iterators_1_1_iterator.html">iterators::Iterator</a>&lt; BASE &gt; &gt; &amp;&amp;source)</td></tr>
<tr class="separator:ac3720091da41e0914322219d223bafbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5f3ed6e93b7307af3a5a1d2936b7e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html#a0a5f3ed6e93b7307af3a5a1d2936b7e1">UBStream</a> (std::vector&lt; std::shared_ptr&lt; <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_processor.html">Processor</a> &gt; &gt; processorsList, std::shared_ptr&lt; <a class="el" href="structaalbatross_1_1utils_1_1iterators_1_1_iterator.html">iterators::Iterator</a>&lt; BASE &gt; &gt; sourceData)</td></tr>
<tr class="separator:a0a5f3ed6e93b7307af3a5a1d2936b7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3cc7bd6ffc970c0c375ea2a9489a57a"><td class="memTemplParams" colspan="2">template&lt;typename Mapper , typename E  = typename std::invoke_result&lt;Mapper, T&gt;::type&gt; </td></tr>
<tr class="memitem:ad3cc7bd6ffc970c0c375ea2a9489a57a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">UBStream</a>&lt; E, T, BASE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html#ad3cc7bd6ffc970c0c375ea2a9489a57a">map</a> (Mapper &amp;&amp;mapper)</td></tr>
<tr class="memdesc:ad3cc7bd6ffc970c0c375ea2a9489a57a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a stream consisting of the results of applying the given function to the elements of this stream.  <br /></td></tr>
<tr class="separator:ad3cc7bd6ffc970c0c375ea2a9489a57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d6295098ca94ace68079914c7b80ec"><td class="memTemplParams" colspan="2">template&lt;typename Mapper &gt; </td></tr>
<tr class="memitem:ac5d6295098ca94ace68079914c7b80ec"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html#ac5d6295098ca94ace68079914c7b80ec">flatten</a> (Mapper &amp;&amp;mapper)</td></tr>
<tr class="memdesc:ac5d6295098ca94ace68079914c7b80ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element. Each mapped stream is closed after its contents have been placed into this stream. (If a mapped stream is null an empty stream is used, instead.)  <br /></td></tr>
<tr class="separator:ac5d6295098ca94ace68079914c7b80ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0258a804567d8923c66e3536c9a7e9"><td class="memTemplParams" colspan="2">template&lt;typename Predicate &gt; </td></tr>
<tr class="memitem:a4c0258a804567d8923c66e3536c9a7e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">UBStream</a>&lt; T, T, BASE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html#a4c0258a804567d8923c66e3536c9a7e9">filter</a> (Predicate &amp;&amp;predicate)</td></tr>
<tr class="memdesc:a4c0258a804567d8923c66e3536c9a7e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects all elements of this stream which satisfy a predicate.  <br /></td></tr>
<tr class="separator:a4c0258a804567d8923c66e3536c9a7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89258e2f31eb7510a05c5ad145da9926"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">UBStream</a>&lt; T, T, BASE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html#a89258e2f31eb7510a05c5ad145da9926">limit</a> (size_t limit)</td></tr>
<tr class="memdesc:a89258e2f31eb7510a05c5ad145da9926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a stream consisting of the elements of this stream, truncated to be no longer than maxSize in length.  <br /></td></tr>
<tr class="separator:a89258e2f31eb7510a05c5ad145da9926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074f8e3ccf66532cbf660095aa6ad59d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">UBStream</a>&lt; T, T, BASE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html#a074f8e3ccf66532cbf660095aa6ad59d">skip</a> (size_t skipCount)</td></tr>
<tr class="memdesc:a074f8e3ccf66532cbf660095aa6ad59d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a stream consisting of the remaining elements of this stream after discarding the first n elements of the stream. If this stream contains fewer than n elements then an empty stream will be returned.  <br /></td></tr>
<tr class="separator:a074f8e3ccf66532cbf660095aa6ad59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2831ccb9164258589f94612ead4f1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">UBStream</a>&lt; <a class="el" href="structaalbatross_1_1utils_1_1collection_1_1_s_deque.html">collection::SDeque</a>&lt; T &gt;, T, BASE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html#aed2831ccb9164258589f94612ead4f1e">sliding</a> (size_t windowSize)</td></tr>
<tr class="memdesc:aed2831ccb9164258589f94612ead4f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Groups elements in fixed size blocks by passing a "sliding window" over them (as opposed to partitioning them, as is done in grouped.) The "sliding window" step is set to one.  <br /></td></tr>
<tr class="separator:aed2831ccb9164258589f94612ead4f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb28b823cd06e3a0f83ed7bda0db9063"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">UBStream</a>&lt; <a class="el" href="structaalbatross_1_1utils_1_1collection_1_1_s_deque.html">collection::SDeque</a>&lt; T &gt;, T, BASE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html#aeb28b823cd06e3a0f83ed7bda0db9063">fixed</a> (size_t windowSize)</td></tr>
<tr class="memdesc:aeb28b823cd06e3a0f83ed7bda0db9063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Groups elements in fixed size blocks by passing a "tumbling window" over them (as opposed to partitioning them, as is done in grouped.) The "tumbling window" step is set to one.  <br /></td></tr>
<tr class="separator:aeb28b823cd06e3a0f83ed7bda0db9063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb4ca179cd9c4b86cf18bc35297a47e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html#aafb4ca179cd9c4b86cf18bc35297a47e">allMatch</a> (std::function&lt; bool(T)&gt; predicate)</td></tr>
<tr class="memdesc:aafb4ca179cd9c4b86cf18bc35297a47e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether all elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result. If the stream is empty then true is returned and the predicate is not evaluated.  <br /></td></tr>
<tr class="separator:aafb4ca179cd9c4b86cf18bc35297a47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4743734d9cbecf221af24fc13a7a261a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html#a4743734d9cbecf221af24fc13a7a261a">anyMatch</a> (std::function&lt; bool(T)&gt; predicate)</td></tr>
<tr class="memdesc:a4743734d9cbecf221af24fc13a7a261a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether any elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result. If the stream is empty then false is returned and the predicate is not evaluated.  <br /></td></tr>
<tr class="separator:a4743734d9cbecf221af24fc13a7a261a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9e0cfddb7cbe44b128088cab131264"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html#acd9e0cfddb7cbe44b128088cab131264">noneMatch</a> (std::function&lt; bool(T)&gt; predicate)</td></tr>
<tr class="memdesc:acd9e0cfddb7cbe44b128088cab131264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether no elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result. If the stream is empty then true is returned and the predicate is not evaluated.  <br /></td></tr>
<tr class="separator:acd9e0cfddb7cbe44b128088cab131264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfdf26256cc69283970e4684f4741fa"><td class="memItemLeft" align="right" valign="top">std::optional&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html#a7cfdf26256cc69283970e4684f4741fa">head</a> ()</td></tr>
<tr class="memdesc:a7cfdf26256cc69283970e4684f4741fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Optional describing the first element of this stream, or an empty Optional if the stream is empty. If the stream has no encounter order, then any element may be returned.  <br /></td></tr>
<tr class="separator:a7cfdf26256cc69283970e4684f4741fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe762ef95d70e521bb51a6f644f5d932"><td class="memItemLeft" align="right" valign="top">std::optional&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html#afe762ef95d70e521bb51a6f644f5d932">tail</a> ()</td></tr>
<tr class="memdesc:afe762ef95d70e521bb51a6f644f5d932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Optional describing the last element of this stream, or an empty Optional if the stream is empty. If the stream has no encounter order, then any element may be returned.  <br /></td></tr>
<tr class="separator:afe762ef95d70e521bb51a6f644f5d932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf42389298a0581d9b36b7299f585b8"><td class="memItemLeft" align="right" valign="top">std::optional&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html#a3bf42389298a0581d9b36b7299f585b8">find</a> (std::function&lt; bool(T)&gt; predicate)</td></tr>
<tr class="memdesc:a3bf42389298a0581d9b36b7299f585b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first element of the sequence satisfying a predicate, if any.  <br /></td></tr>
<tr class="separator:a3bf42389298a0581d9b36b7299f585b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f358440638cbf9f2f46b33d3250ce00"><td class="memItemLeft" align="right" valign="top">std::optional&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html#a1f358440638cbf9f2f46b33d3250ce00">max</a> ()</td></tr>
<tr class="memdesc:a1f358440638cbf9f2f46b33d3250ce00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max of all the elements in this stream.  <br /></td></tr>
<tr class="separator:a1f358440638cbf9f2f46b33d3250ce00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99672960c71e51f103da933819edc681"><td class="memItemLeft" align="right" valign="top">std::optional&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html#a99672960c71e51f103da933819edc681">min</a> ()</td></tr>
<tr class="memdesc:a99672960c71e51f103da933819edc681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Min of all the elements in this stream.  <br /></td></tr>
<tr class="separator:a99672960c71e51f103da933819edc681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e58bf29ab7404040c234820c21a0035"><td class="memTemplParams" colspan="2">template&lt;typename Consumer &gt; </td></tr>
<tr class="memitem:a8e58bf29ab7404040c234820c21a0035"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html#a8e58bf29ab7404040c234820c21a0035">forEach</a> (Consumer &amp;&amp;consumer)</td></tr>
<tr class="memdesc:a8e58bf29ab7404040c234820c21a0035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an action for each element of this stream.This is a terminal operation.  <br /></td></tr>
<tr class="separator:a8e58bf29ab7404040c234820c21a0035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777e0f02cc8453b6390f297d79ee3554"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html#a777e0f02cc8453b6390f297d79ee3554">toVector</a> ()</td></tr>
<tr class="separator:a777e0f02cc8453b6390f297d79ee3554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a6c1468203a3909920474d6cda066f"><td class="memTemplParams" colspan="2">template&lt;typename Supplier , typename Accumulator , typename Finisher &gt; </td></tr>
<tr class="memitem:aa3a6c1468203a3909920474d6cda066f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html#aa3a6c1468203a3909920474d6cda066f">collect</a> (<a class="el" href="classaalbatross_1_1utils_1_1streams_1_1_collector.html">Collector</a>&lt; Supplier, Accumulator, Finisher &gt; &amp;&amp;collector)</td></tr>
<tr class="memdesc:aa3a6c1468203a3909920474d6cda066f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a mutable reduction operation on the elements of this stream. A mutable reduction is one in which the reduced value is a mutable result container, such as an ArrayList, and elements are incorporated by updating the state of the result rather than by replacing the result. This produces a result equivalent to:  <br /></td></tr>
<tr class="separator:aa3a6c1468203a3909920474d6cda066f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, typename S = T, typename BASE = T&gt;<br />
class aalbatross::utils::streams::UBStream&lt; T, S, BASE &gt;</div><p>A sequence of elements supporting sequential and parallel aggregate operations on unbounded stream. </p>
<p>To perform a computation, stream operations are composed into a stream pipeline. AType stream pipeline consists of a source (which might be an array, a collection, a generator function, an I/O channel, etc), zero or more intermediate operations (which transform a stream into another stream, such as filter(Predicate)), and a terminal operation (which produces a result or side-effect, such as count() or forEach(Consumer)). Streams are lazy; computation on the source data is only performed when the terminal operation is initiated, and source elements are consumed only as needed. Collections and streams, while bearing some superficial similarities, have different goals. Collections are primarily concerned with the efficient management of, and access to, their elements. By contrast, streams do not provide a means to directly access or manipulate their elements, and are instead concerned with declaratively describing their source and the computational operations which will be performed in aggregate on that source. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>target stream type </td></tr>
    <tr><td class="paramname">S</td><td>source stream type </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a755f7aa1e1f9631beb277a5f4d4cd077" name="a755f7aa1e1f9631beb277a5f4d4cd077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a755f7aa1e1f9631beb277a5f4d4cd077">&#9670;&#160;</a></span>UBStream() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T, typename BASE  = T&gt; </div>
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">aalbatross::utils::streams::UBStream</a>&lt; T, S, BASE &gt;::UBStream </td>
          <td>(</td>
          <td class="paramtype">Iter &amp;&amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter &amp;&amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac3720091da41e0914322219d223bafbf" name="ac3720091da41e0914322219d223bafbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3720091da41e0914322219d223bafbf">&#9670;&#160;</a></span>UBStream() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T, typename BASE  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">aalbatross::utils::streams::UBStream</a>&lt; T, S, BASE &gt;::UBStream </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structaalbatross_1_1utils_1_1iterators_1_1_iterator.html">iterators::Iterator</a>&lt; BASE &gt; &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a5f3ed6e93b7307af3a5a1d2936b7e1" name="a0a5f3ed6e93b7307af3a5a1d2936b7e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5f3ed6e93b7307af3a5a1d2936b7e1">&#9670;&#160;</a></span>UBStream() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T, typename BASE  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">aalbatross::utils::streams::UBStream</a>&lt; T, S, BASE &gt;::UBStream </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_processor.html">Processor</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>processorsList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structaalbatross_1_1utils_1_1iterators_1_1_iterator.html">iterators::Iterator</a>&lt; BASE &gt; &gt;&#160;</td>
          <td class="paramname"><em>sourceData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aafb4ca179cd9c4b86cf18bc35297a47e" name="aafb4ca179cd9c4b86cf18bc35297a47e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb4ca179cd9c4b86cf18bc35297a47e">&#9670;&#160;</a></span>allMatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T, typename BASE  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">aalbatross::utils::streams::UBStream</a>&lt; T, S, BASE &gt;::allMatch </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(T)&gt;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether all elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result. If the stream is empty then true is returned and the predicate is not evaluated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>stateless predicate to apply to elements of this stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if either all elements of the stream match the provided predicate or the stream is empty, otherwise false </dd></dl>

</div>
</div>
<a id="a4743734d9cbecf221af24fc13a7a261a" name="a4743734d9cbecf221af24fc13a7a261a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4743734d9cbecf221af24fc13a7a261a">&#9670;&#160;</a></span>anyMatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T, typename BASE  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">aalbatross::utils::streams::UBStream</a>&lt; T, S, BASE &gt;::anyMatch </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(T)&gt;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether any elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result. If the stream is empty then false is returned and the predicate is not evaluated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>stateless predicate to apply to elements of this stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any elements of the stream match the provided predicate, otherwise false </dd></dl>

</div>
</div>
<a id="aa3a6c1468203a3909920474d6cda066f" name="aa3a6c1468203a3909920474d6cda066f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a6c1468203a3909920474d6cda066f">&#9670;&#160;</a></span>collect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T, typename BASE  = T&gt; </div>
<div class="memtemplate">
template&lt;typename Supplier , typename Accumulator , typename Finisher &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">aalbatross::utils::streams::UBStream</a>&lt; T, S, BASE &gt;::collect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaalbatross_1_1utils_1_1streams_1_1_collector.html">Collector</a>&lt; Supplier, Accumulator, Finisher &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>collector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a mutable reduction operation on the elements of this stream. A mutable reduction is one in which the reduced value is a mutable result container, such as an ArrayList, and elements are incorporated by updating the state of the result rather than by replacing the result. This produces a result equivalent to: </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Supplier</td><td></td></tr>
    <tr><td class="paramname">Accumulator</td><td></td></tr>
    <tr><td class="paramname">Finisher</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collector</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result from the collector </dd></dl>

</div>
</div>
<a id="a4c0258a804567d8923c66e3536c9a7e9" name="a4c0258a804567d8923c66e3536c9a7e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0258a804567d8923c66e3536c9a7e9">&#9670;&#160;</a></span>filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T, typename BASE  = T&gt; </div>
<div class="memtemplate">
template&lt;typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">UBStream</a>&lt; T, S &gt; <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">aalbatross::utils::streams::UBStream</a>&lt; T, S, BASE &gt;::filter </td>
          <td>(</td>
          <td class="paramtype">Predicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Selects all elements of this stream which satisfy a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>stateless predicated which is applied to all elements of stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html" title="A sequence of elements supporting sequential and parallel aggregate operations on bound container.">Stream</a> of filtered elements as per predicate. </dd></dl>

</div>
</div>
<a id="a3bf42389298a0581d9b36b7299f585b8" name="a3bf42389298a0581d9b36b7299f585b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf42389298a0581d9b36b7299f585b8">&#9670;&#160;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T, typename BASE  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; T &gt; <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">aalbatross::utils::streams::UBStream</a>&lt; T, S, BASE &gt;::find </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(T)&gt;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first element of the sequence satisfying a predicate, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>stateless predicate to apply to elements of this stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an Optional describing the first element of this stream which matches with this predicate, or an empty Optional if the stream is empty </dd></dl>

</div>
</div>
<a id="aeb28b823cd06e3a0f83ed7bda0db9063" name="aeb28b823cd06e3a0f83ed7bda0db9063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb28b823cd06e3a0f83ed7bda0db9063">&#9670;&#160;</a></span>fixed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T, typename BASE  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">UBStream</a>&lt; std::deque&lt; T &gt;, T, BASE &gt; <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">aalbatross::utils::streams::UBStream</a>&lt; T, S, BASE &gt;::fixed </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>windowSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Groups elements in fixed size blocks by passing a "tumbling window" over them (as opposed to partitioning them, as is done in grouped.) The "tumbling window" step is set to one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">windowSize</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new stream of containers </dd></dl>

</div>
</div>
<a id="ac5d6295098ca94ace68079914c7b80ec" name="ac5d6295098ca94ace68079914c7b80ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d6295098ca94ace68079914c7b80ec">&#9670;&#160;</a></span>flatten()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T, typename BASE  = T&gt; </div>
<div class="memtemplate">
template&lt;typename Mapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">aalbatross::utils::streams::UBStream</a>&lt; T, S, BASE &gt;::flatten </td>
          <td>(</td>
          <td class="paramtype">Mapper &amp;&amp;&#160;</td>
          <td class="paramname"><em>mapper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element. Each mapped stream is closed after its contents have been placed into this stream. (If a mapped stream is null an empty stream is used, instead.) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Mapper</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapper</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new flatten stream </dd></dl>

</div>
</div>
<a id="a8e58bf29ab7404040c234820c21a0035" name="a8e58bf29ab7404040c234820c21a0035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e58bf29ab7404040c234820c21a0035">&#9670;&#160;</a></span>forEach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T, typename BASE  = T&gt; </div>
<div class="memtemplate">
template&lt;typename Consumer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">aalbatross::utils::streams::UBStream</a>&lt; T, S, BASE &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">Consumer &amp;&amp;&#160;</td>
          <td class="paramname"><em>consumer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an action for each element of this stream.This is a terminal operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Consumer</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">consumer</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7cfdf26256cc69283970e4684f4741fa" name="a7cfdf26256cc69283970e4684f4741fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cfdf26256cc69283970e4684f4741fa">&#9670;&#160;</a></span>head()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T, typename BASE  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; T &gt; <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">aalbatross::utils::streams::UBStream</a>&lt; T, S, BASE &gt;::head </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an Optional describing the first element of this stream, or an empty Optional if the stream is empty. If the stream has no encounter order, then any element may be returned. </p>
<dl class="section return"><dt>Returns</dt><dd>an Optional describing the first element of this stream, or an empty Optional if the stream is empty </dd></dl>

</div>
</div>
<a id="a89258e2f31eb7510a05c5ad145da9926" name="a89258e2f31eb7510a05c5ad145da9926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89258e2f31eb7510a05c5ad145da9926">&#9670;&#160;</a></span>limit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T, typename BASE  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">UBStream</a>&lt; T, T, BASE &gt; <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">aalbatross::utils::streams::UBStream</a>&lt; T, S, BASE &gt;::limit </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a stream consisting of the elements of this stream, truncated to be no longer than maxSize in length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">limit</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new stream </dd></dl>

</div>
</div>
<a id="ad3cc7bd6ffc970c0c375ea2a9489a57a" name="ad3cc7bd6ffc970c0c375ea2a9489a57a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3cc7bd6ffc970c0c375ea2a9489a57a">&#9670;&#160;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T, typename BASE  = T&gt; </div>
<div class="memtemplate">
template&lt;typename Mapper , typename E  = typename std::invoke_result&lt;Mapper, T&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">UBStream</a>&lt; E, S &gt; <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">aalbatross::utils::streams::UBStream</a>&lt; T, S, BASE &gt;::map </td>
          <td>(</td>
          <td class="paramtype">Mapper &amp;&amp;&#160;</td>
          <td class="paramname"><em>mapper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a stream consisting of the results of applying the given function to the elements of this stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Fun</td><td>It is a type of function which can map elements from one type to another. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapper</td><td>is mapping function an object of Fun to transform element of stream from one type to other </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_stream.html" title="A sequence of elements supporting sequential and parallel aggregate operations on bound container.">Stream</a> object with composed mapper function. </dd></dl>

</div>
</div>
<a id="a1f358440638cbf9f2f46b33d3250ce00" name="a1f358440638cbf9f2f46b33d3250ce00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f358440638cbf9f2f46b33d3250ce00">&#9670;&#160;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T, typename BASE  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; T &gt; <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">aalbatross::utils::streams::UBStream</a>&lt; T, S, BASE &gt;::max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Max of all the elements in this stream. </p>
<dl class="section return"><dt>Returns</dt><dd>Optionally max element if the stream is non empty else empty optional. </dd></dl>

</div>
</div>
<a id="a99672960c71e51f103da933819edc681" name="a99672960c71e51f103da933819edc681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99672960c71e51f103da933819edc681">&#9670;&#160;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T, typename BASE  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; T &gt; <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">aalbatross::utils::streams::UBStream</a>&lt; T, S, BASE &gt;::min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Min of all the elements in this stream. </p>
<dl class="section return"><dt>Returns</dt><dd>Optionally min element if the stream is non empty else empty optional. </dd></dl>

</div>
</div>
<a id="acd9e0cfddb7cbe44b128088cab131264" name="acd9e0cfddb7cbe44b128088cab131264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd9e0cfddb7cbe44b128088cab131264">&#9670;&#160;</a></span>noneMatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T, typename BASE  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">aalbatross::utils::streams::UBStream</a>&lt; T, S, BASE &gt;::noneMatch </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(T)&gt;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether no elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result. If the stream is empty then true is returned and the predicate is not evaluated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>stateless predicate to apply to elements of this stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if either no elements of the stream match the provided predicate or the stream is empty, otherwise false </dd></dl>

</div>
</div>
<a id="a074f8e3ccf66532cbf660095aa6ad59d" name="a074f8e3ccf66532cbf660095aa6ad59d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a074f8e3ccf66532cbf660095aa6ad59d">&#9670;&#160;</a></span>skip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T, typename BASE  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">UBStream</a>&lt; T, T, BASE &gt; <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">aalbatross::utils::streams::UBStream</a>&lt; T, S, BASE &gt;::skip </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>skipCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a stream consisting of the remaining elements of this stream after discarding the first n elements of the stream. If this stream contains fewer than n elements then an empty stream will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">skipCount</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new stream </dd></dl>

</div>
</div>
<a id="aed2831ccb9164258589f94612ead4f1e" name="aed2831ccb9164258589f94612ead4f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed2831ccb9164258589f94612ead4f1e">&#9670;&#160;</a></span>sliding()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T, typename BASE  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">UBStream</a>&lt; std::deque&lt; T &gt;, T, BASE &gt; <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">aalbatross::utils::streams::UBStream</a>&lt; T, S, BASE &gt;::sliding </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>windowSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Groups elements in fixed size blocks by passing a "sliding window" over them (as opposed to partitioning them, as is done in grouped.) The "sliding window" step is set to one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">windowSize</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new stream of containers </dd></dl>

</div>
</div>
<a id="afe762ef95d70e521bb51a6f644f5d932" name="afe762ef95d70e521bb51a6f644f5d932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe762ef95d70e521bb51a6f644f5d932">&#9670;&#160;</a></span>tail()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T, typename BASE  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; T &gt; <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">aalbatross::utils::streams::UBStream</a>&lt; T, S, BASE &gt;::tail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an Optional describing the last element of this stream, or an empty Optional if the stream is empty. If the stream has no encounter order, then any element may be returned. </p>
<dl class="section return"><dt>Returns</dt><dd>an Optional describing the last element of this stream, or an empty Optional if the stream is empty </dd></dl>

</div>
</div>
<a id="a777e0f02cc8453b6390f297d79ee3554" name="a777e0f02cc8453b6390f297d79ee3554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777e0f02cc8453b6390f297d79ee3554">&#9670;&#160;</a></span>toVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S  = T, typename BASE  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">aalbatross::utils::streams::UBStream</a>&lt; T, S, BASE &gt;::toVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>aalbatross/utils/streams/<a class="el" href="ub__stream_8h_source.html">ub_stream.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceaalbatross.html">aalbatross</a></li><li class="navelem"><a class="el" href="namespaceaalbatross_1_1utils.html">utils</a></li><li class="navelem"><a class="el" href="namespaceaalbatross_1_1utils_1_1streams.html">streams</a></li><li class="navelem"><a class="el" href="structaalbatross_1_1utils_1_1streams_1_1_u_b_stream.html">UBStream</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
